<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>箫竹影</title>
  
  <subtitle>箫竹影的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhouyuhong.top/"/>
  <updated>2018-02-11T06:06:55.674Z</updated>
  <id>http://zhouyuhong.top/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql-InnoDB内部原理浅析</title>
    <link href="http://zhouyuhong.top/2018/02/09/Mysql-InnoDB%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>http://zhouyuhong.top/2018/02/09/Mysql-InnoDB内部原理浅析/</id>
    <published>2018-02-09T01:57:48.000Z</published>
    <updated>2018-02-11T06:06:55.674Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL是一个应用非常广泛的开源数据库，同时由于它的逻辑架构十分出色，所以几乎可以用于各行各业中。它的插件式的存储引擎，将查询处理和其他的系统任务、数据存放获取分离开来。所以，用户可以根据自己的业务需要，选择自己适合的存储引擎。</p><hr><p>首先展示一下Mysql的架构图<br><img src="http://strugglepages-1253927162.coscd.myqcloud.com/2018-02-09-mysql%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt=""></p><ol><li><strong>Connection Pool</strong>：该层就是连接层，包含了一些客户端和连接服务，它包含了各种本地SOCKET通信，或者基于服务端/客户端的类TCP/IP的通信。主要负责一些连接管理，权限认证等安全校验。同时，采用线程池的模型，为客户端提供线程访问，并且也支持基于SSL的安全连接机制。</li><li><strong>SQL Interface</strong>，<strong>Parser</strong>，<strong>Optimizer</strong>，<strong>Caches&amp;Buffers</strong>：该层主是处理层，主要负责处理各种操作，例如Sql接口，解析SQL语句，同时优化语句，缓存的存取等功能。在这一层中，Mysql会将我们的SQL语句进行解析，生成解析树，同时会对查询进行优化，判断查询表的先后顺序，是否利用索引等，最后执行优化后的操作。针对select语句，还会去查询缓存，如果缓存足够大，对整个查询的效率也是有质的提升的。当然，一些跨存储引擎的功能，例如存储过程的执行，函数的执行等，也是放在这一层的。</li><li><strong>Plugin Storage Engines</strong>：该层就是我们在顶部提到的插件式存储引擎，这一层就是实际对数据进行存储和获取的一层，服务器通过存储引擎提供的各种API，来进行数据的操作，同时各个存储引擎的功能又有所不同，我们可以根据实际需要进行选择。</li><li><strong>File System</strong>，<strong>File &amp;&amp; Log</strong>：该层就是数据存储层，主要是将我们的数据存入各种设备的文件系统之上，同时负责与存储引擎进行交互。</li><li><strong>Management Services</strong> &amp; <strong>Utilities</strong>：该层是管理服务工具层，这一层主要负责的是Mysql的一些关系服务，例如恢复，备份，集群等操作。</li></ol><hr><p>从上面的架构图上，我们可以看到，plguin engines这一部分就是mysql整个架构图的精华之所在，通过插件式的设计思想，就可以涌生出大量的优秀的存储引擎，常用有myisam以及innoDB两种，那么，接下来，我们就重点介绍一下我们用得最多的InnoDB这个存储引擎。</p><p>####InnoDB：<br>InnoDB是一个优秀的存储引擎，可以支持譬如索引查询，行锁，表锁等特性，故也是大家用得最多的一个存储引擎。那么，InnoDB内部的数据文件又是以什么样的形式存储的呢？这里我们就不得不来介绍一下InnoDB的共享表空间和独立表空间</p><ul><li>共享表空间：即每一个数据库的所有表信息，数据信息，索引信息全部放在一个文件空间里面。</li><li>独立表空间：即每一个数据库的所有表都单独生成对应的文件。每一个表对应两个文件，一个是表的描述，另一个就是表的数据和索引。</li></ul><p><strong>共享表空间优点</strong>：将所有的表数据放在一起，可以方便的进行管理，同时，可以将数据进行分文件存储，也就是说一个表的数据可能分布在多个文件中，每一个文件有着固定的大小限制，但是文件数量可以不断增加，所以，其大小限制不再受文件大小限制而限制，而是以自己本身的数据为准了。<br><strong>共享表空间缺点</strong>：由于所有的索引和数据放在一起，那么当进行大批量删除的时候，必然会造成文件的空间有大量的空隙存在，这样会造成大量的空间浪费，所以特别是日志系统等数据量大并且存放时间不多的系统，就不适宜用共享表空间来做。</p><p><strong>独立表空间有点</strong>：由于各个表的数据分开存放，那么当有大批量删除的时候，就可以对文件进行空间空隙的回收操作了。同时，对于数据的影响性也会更小，因为某一个表的数据有问题，不会影响其他表的数据，并且做数据的物理迁移也很方便，如果我们需要这个库的某一张或某几张表，那么仅仅只需要对这几张表做复制即可。<br><strong>独立表空间缺点</strong>：显然，独立表空间不会把数据放在多个文件中，那么文件大小就成了数据的限制，如果数据量超过文件大小，显然就会对数据造成丢失。</p><hr><p>介绍完了InnoDB的文件存储形式，接下来我们就介绍一下InnoDB所使用到的索引格式。InnoDB中使用的索引通常是b+树和hash两种。但是普遍使用的是b+树。b+树的概念这里不多做介绍，相信你能在网上找到比我更牛逼的大神并通过简单的话语来介绍b+树，这里只是简单的描述一下b+树的基本概念。<br>b+树不再是纯粹的二叉树了，而是被称为<strong>多路搜索树</strong>，其每一个父节点允许拥有多余两个的孩子节点。同时，非叶子结点存放的是索引量，通常是一个范围，只有最后的叶子结点才会存放具体的数据内容。如下图所示就是一个基本的b+树：<br><img src="http://strugglepages-1253927162.coscd.myqcloud.com/2018-02-11-b-%E6%A0%91.jpg" alt=""><br>我们用一个简单的例子来描述一下b+树的搜索流程，假设此时我们要找索引为4的具体数据。</p><ol><li>首先查询根节点，发现4在3～5这个中间，于是便进入它的中间子节点中。</li><li>此时开始继续查询这个节点，发现4正好在这个节点上，并且这个节点是叶子结点，所以就可以直接返回数据了。</li></ol><p>这里额外补充一下，在b+树之前，还有b树，那么b树与b+树又有什么不同呢？既然它们都有一个共同的字母b，那么显然它们的组成结构必定是类似的。下图就是b树的数据结构，同样，它也是<strong>多路搜索树</strong>。<br><img src="http://strugglepages-1253927162.coscd.myqcloud.com/2018-02-11-b%E6%A0%91.png" alt=""><br>其实可以看出，b树与b+树唯一的不同点就是b树的每一个结点都同时存放了数据和索引信息，而b+树的非叶子结点中只会有索引，叶子节点才会有具体的数据。而它的检索方式同b+树。</p><p>那么，既然b树也满足快速查找的目的，为什么还会有b+树呢？其实这就要从操作系统说起了，b+树的磁盘读写代价更低，很简单，假设此时我们有同样的一堆数据，由于b树的每一个结点都存放了索引和数据，所以每一个结点的文件大小必然比b+树大，那么当数据库进行查找时，同样大小的内存空间，读取b树结点数必然要比b+树小，假设固定内存大小，b树可以一次性读取5个节点的内容，那么b+树也许一次就能读取20个。所以如果我们查询的结点数据索引在15号节点上，那么b树就需要读取三次结点，而b+树读取二次就能查询出结果了（一次读取索引，第二次根据索引读取具体的数据）。不过b树也不是完全没有优点，假设此时索引在1号节点上，那么b树第一次就能取到数据，而b+树不得不通过两次读取来获取数据。</p><hr><p>同时，InnoDB内部的索引又分为聚集索引和辅助索引，二者的区别是聚集索引的行数据与主键索引存放在一起的，而辅助索引只存放索引的键数据和主键。</p><p>对于聚集索引而言，是根据主键来进行生成的，所以一张表只能有一个聚集索引，由于聚集索引存放了数据，所以检索效率十分高，而MySQL的查询优化器也会优先靠拢聚集索引。<br>对于辅助索引而言，由于只是存放索引数据和主键，所以通过辅助索引查询到的数据，结果是对应的主键信息，那么此时还需要根据主键信息去聚集索引中查询对应的数据，所以执行效率没有聚集索引高，但是这里也有一点要注意，如果查询优化器发现我们查询的字段正好就是辅助索引的索引键，那么mysql就可以直接返回索引数据作为查询数据，而无需再次查询聚集索引获取数据了。</p><p>所以，根据这个特性，在Mysql的优化查询方案中，就有一种叫做覆盖索引的优化方式，具体就是将我们需要查询的字段生成联合索引，那么根据前面介绍的辅助索引的查询特点，mysql就可以直接通过查询索引文件来返回数据了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL是一个应用非常广泛的开源数据库，同时由于它的逻辑架构十分出色，所以几乎可以用于各行各业中。它的插件式的存储引擎，将查询处理和其他的系统任务、数据存放获取分离开来。所以，用户可以根据自己的业务需要，选择自己适合的存储引擎。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先展示一下Mys
      
    
    </summary>
    
      <category term="Mysql" scheme="http://zhouyuhong.top/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="http://zhouyuhong.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper-Paxos算法理解</title>
    <link href="http://zhouyuhong.top/2018/01/14/Zookeeper-Paxos%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
    <id>http://zhouyuhong.top/2018/01/14/Zookeeper-Paxos算法理解/</id>
    <published>2018-01-14T11:40:23.000Z</published>
    <updated>2018-01-15T10:41:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。</p><hr><h3 id="分布式应用程序协调技术"><a href="#分布式应用程序协调技术" class="headerlink" title="分布式应用程序协调技术"></a>分布式应用程序协调技术</h3><p>要想了解zookeeper的工作机制，首先就要明白zookeeper是用来做什么的。我们前面提到过，zookeeper是一个分布式的应用程序协调服务，那么，什么又是分布式协调呢？其实可以简单的从字面上来理解，就是在多个应用程序（进程）之间来进行协调的，那么，这里的协调又是什么的？其实就是协调共享资源，我们知道，单机多线程应用环境下，对于共享资源，我们可以通过多线程安全技术来进行控制，其底层不外乎就是采用锁机制来保证同一时刻只能允许一个线程进行操作，那么分布式环境下就不那么容易了，相互隔离的各个应用之间，同样需要介入一项技术来保证顺序的访问某个临界资源，那么zookeeper就是这样一项技术。<br>而zookeeper就起到了前面介绍的单机多线程环境下的锁的作用，在分布式环境下，这种锁机制我们又称为分布式锁。</p><hr><h3 id="Paxos算法理论"><a href="#Paxos算法理论" class="headerlink" title="Paxos算法理论"></a>Paxos算法理论</h3><p>提到分布式锁，就不得不先来介绍一下paxos算法，这也是本篇博客的重点，简单的通过一句话来总结，paxos算法可以做到：</p><blockquote><p>所有节点都写入同一个值，并且之后不会再改变这个值</p></blockquote><p>而paxos算法又是基于2pc（2阶段提交协议）来做的，简单的说，其内部有一个提案机制，类似于议会制，通过两个阶段来完成一个提案：</p><ol><li>提案提交阶段</li><li>提案执行阶段</li></ol><p>其中，每一次提交阶段都会使用一个全局唯一的版本号，但是不代表整个提交阶段就一个版本，因为可能发生在第一个提案处于提交阶段的时候，又有第二个提案被发起了，那么这两个提案就会使用两个不同的版本号。同时需要注意的是，在一个流程中，当第二个阶段已经确认出了一个结果之后，即使此时还有处于第一个阶段的提案，也必须要同步成第二个阶段的提案。直到整个流程结束。</p><p>而整个全过程又需要多个角色来共同协作完成</p><ol><li><strong>proposer</strong>—提案发起者：proposer可以有多个，每一个proposer可以发起一个提案（该提案来自于客户端发起的某一个操作），提案可以是任何操作，比如修改某一个文件的值，删除某一个元素等等，多个proposer可以分别提出不同的提案，例如a发起修改某个元素x的值，b发起删除x这个元素，但是在一轮的流程中，最后只允许有一个提案被批准。</li><li><strong>acceptor</strong>—提案接受者：接受者有多个，proposer发起的提案必须有超过半数的acceptor批准，才能通过这个提案（假设此时有n个接受者，那么每一个提案必须至少有n / 2 + 1个acceptor的批准，才能通过，类似于我们常说的少数服从多数）；需要注意的是，各个acceptor是相互独立并且完全对等的。</li><li><strong>learner</strong>—提案学习者：这个角色就是用作最终学习决策使用的，主要用于当有不同的提案提交后，却发现acceptor已经同意了其他的提案，那么本次提议为了保证通过，就不得不将自己的提案修改为已经同意过的那个提案，而这个修改就是通过learner来进行同步的。</li><li><strong>client</strong>—客户端：即发起某个操作的角色。</li></ol><p>这几个角色的作用已经做了一个简单的介绍，并且为了保证少数服从多数，就要求我们的提案接受者数量至少是一个大于3的奇数个数量；介绍了这么多，相信看起来还是有点懵逼，接下来我们就用一个例子来补充讲解paxos算法的工作原理：<br>假设此时有两个部门，去争夺公司的某一个项目，每一个部门都派出了自己最得力的外交选手A和B，而公司的项目决定人有三个，张总，李总，王总<br>第一阶段：    </p><ul><li>此时A选手带上自己部门的贿赂奖金（类似于版本号）100元，去贿赂三个老总，显然，此时由于没有其他部门竞争，于是A选手顺利的与三个老总达成一致。</li><li>当A已经和张总以及李总签署完初步协议之后，此时不巧B选手也来了，B选手很聪明，他发现A还没有给王总签协议，于是他拿出了200元来贿赂王总，当A此时来找王总签字时，王总却说B已经给了我200元了，显然你的100元我是不会同意的。不过由于A已经和张总、李总初步达成了一致，产生了多数派，所以A也不必担心，于是A就跑回部门去说明本次交涉的结果，并且去取最终的合同，来找各位老总签字了。（这里注意一点，如果此时没有达成多数派，那么A肯定就会继续提高自己的价格，然后继续走一遍流程）</li><li>B显然最终肯定会另外的两个老总达成协议，因为他的钱比较多；当这轮结束之后，此时三个老总手里拿着的是B的协议（注意此时A并不知道这件事，他还以为自己的提案被接受了呢）。</li></ul><p>总而言之，第一阶段的最终目的就是要初步达成一个唯一的提案。</p><p>第二阶段：</p><ul><li>当A拿出了最终合同来找各位老总签字的时候，发现各位老总变卦了（因为第一个阶段最终达成的是B的初步协议），此时A便立刻进行下一步方案，提交自己的价格到300元，然后重新开始走第一个流程，但是当A与张总达成一致的时候，此时B发现情况不对，于是立刻找李总和王总达成了最终合同，同样此时已经达成了多数派，那么此时整个流程就会以B作为最终的结果了，显然，B所在的部门成功的中标，但是流程还没有结束，因为此时A还在重新走第一个流程。</li><li>此时A继续去找李总走第一个流程，虽然李总很眼馋这次的300元，但是由于已经和B达成了最终协议，所以他也不得不告诉A，他们已经决定让B所在的部门来做这个任务了。但是A心想：“吗的，老子刚在已经立下军令状了，总不可能就这样就回去了吧”，于是此时A灵机一动，把自己的提案内容擅自改成了B的，所以此时A手里也拿着B的提案内容。同时给李总签字，李总当然就同意了，此时又达成了多数派，并且此时再也没有B来搅局了。所以显然A的提案最终也会通过（当王总签字时，发现A的提案与B一样，所以他也就没有计较了）。</li></ul><p>这样做我们发现虽然最后A不得不违心的提交了B的提案，但是最终结果却是正确的。所以paxos就是通过这种方式来保证一致性的，即第二阶段优先进入的提案，会被执行，即使这个时候有更高的版本（例子中的贿赂金额），也会进行强制学习，让这些提案者同步自己的信息。这也是paxos解决一致性所采取的方式。</p><p>从上面介绍的机制可以看出，paxos算法真正耗时的就是在第二步了，这里需要超过半数的acceptor进行批准，中途必然会导致大量的io开销，同时在极限情况下，可能某个proposer发起的提案被一部分acceptor接受，而另一个proposer的提案被另一些acceptor接受，就会造成相互间的冲突，那么就会导致整个流程被大量的耗时在同步阶段。还是以上面例子，假设在第一个阶段，A通知了张总，B通知了王总和李总（此时已经满足多数派，B就回去拿合同），此时A去找李总或者王总时，就会发现自己的提案没有优势，那么他就必然会继续加钱，此时假设是300，通知了张总和王总（同样满足多数派，此时A就回去拿最终的合同了），此时B执行第二个阶段，发现自己的提案被A替代，那么此时B会继续加到400，然后通知王总和李总（然后又回去拿合同），此时A回来签署合同，发现又被B抬价了，那么A又继续加钱。。。所以我们不难发现，只要没有最终执行第二个阶段，就可能会导致多个提案被无限的更改，这就是所谓的活锁。由于paxos会导致活锁问题，所以市面上所有成熟的项目，都是基于paxos算法进行改进的，比如fast-paxos算法，zk的zab协议，都是用来解决这种现象的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;分布式应用程序协调技术&quot;&gt;&lt;a href=&quot;#分布式应用程序协调技术&quot; clas
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://zhouyuhong.top/categories/Zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://zhouyuhong.top/tags/zookeeper/"/>
    
      <category term="分布式" scheme="http://zhouyuhong.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从同步原理</title>
    <link href="http://zhouyuhong.top/2017/12/29/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://zhouyuhong.top/2017/12/29/MySQL主从同步实现原理/</id>
    <published>2017-12-29T08:02:58.000Z</published>
    <updated>2018-01-14T11:36:17.070Z</updated>
    
    <content type="html"><![CDATA[<p>mysql的主从同步给构建大型系统带来了无限的可能性，接下来我们就简单介绍一下mysql的主动同步的基本原理以及实现方式。</p><hr><h3 id="什么是主从同步"><a href="#什么是主从同步" class="headerlink" title="什么是主从同步"></a>什么是主从同步</h3><p>在mysql集群这个体系中，mysql会单独拿出一台机器作为主机器master，我们所有的insert，update，delete操作全部都在这台master服务器的库上，然后其他的机器全部作为这台机去的从节点slave，从节点的mysql会去master机器上获取最近一段时间的操作（通常很短暂），然后同步更新自己的数据，这样就达到了主从同步的操作。</p><p>这样的不同于传统的单机操作模式，带来的好处就是可以实现读写分离，集群扩展，数据的分区容错和高可用，数据备份等。</p><h3 id="主从同步实现方式"><a href="#主从同步实现方式" class="headerlink" title="主从同步实现方式"></a>主从同步实现方式</h3><p>那么，mysql是通过怎样的一种方式来实现主从同步的呢？其实很简单，在mysql内部，会有一个特殊的文件来记录着master上发生的一切，这个文件被叫做binary-log，俗称bin-log，这个文件所记录的操作被成为主从同步事件，每一个事件代表着一系列的intert，update，delete等操作，总体上，主从同步事件又大致分为三种：</p><ul><li>statement 即master上执行的所有sql语句会被完整的记录到bin-log中</li><li>row 即每一条记录的变化情况会被记录到bin-log中</li><li>mix 即同时混合前面的两种事件，结合使用</li></ul><p>当slave机器连接到master机器上时，master机器会开启一个叫做bin-dump的线程来管理这一个连接，当master的bin-log有改变的时候，dump线程会通知slave机器，同时将自己的更新内容同步给slave机器节点中。所以，一主多从下，master会有多个dump线程来维护多个slave服务器</p><p>同时，slave机器自身也会开启两个线程，一个叫做io线程，一个叫做sql线程，具体操作过程如下：</p><ul><li>io线程：接受master返回的bin-log中的更新内容，记录到本地的一个叫做中继日志中(relay.log)，当同步完成后，它会休眠，直到下一次master有更新时，通知它。</li><li>sql线程：从中继日志中获取最新的改变内容，然后在本地同步执行这些操作。这里有一个限制：master上可能有许多不影响的操作，它会并行执行，但是slave在同步这些操作时，只会串行化的执行这些操作。</li></ul><p>通过在master上执行命令可以查看当前master的dump线程：<br><img src="http://images-enjoylife.bj.bcebos.com/articles%2FMysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%2Fmysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A51.png" alt="Alt mysql master dump线程"></p><p>当然，在slave上执行命令也可以查看自己的io线程和sql线程：<br><img src="http://images-enjoylife.bj.bcebos.com/articles%2FMysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%2Fmysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A52.png" alt="Alt mysql slave io与sql线程"><br>从sql线程中我们可以看到确实是从一个叫relay.log中获取同步操作的。</p><h3 id="扩展slave节点"><a href="#扩展slave节点" class="headerlink" title="扩展slave节点"></a>扩展slave节点</h3><p>通常一个业务最开始都是从单机逐渐到集群的，所以mysql也是一样，我们很少有一开始就设置主从架构的应用，那么，如何在一个已有的服务器中添加从机器，或者从某一个已经有主从架构的服务商扩展一个新的slave呢？其实大致会有如下的几种方式：</p><ul><li>冷拷贝方式：即停止掉master节点，先进行数据复制，然后再启动，显然，这不是一个好的方案。</li><li>热拷贝方式：如果你是使用的myisam的存储引擎，那么你可以使用mysqlhotcopy程序来实现拷贝操作。</li><li>使用mysqldump方式：此时如果我们没有用myisam引擎，那么我们就可以通过dump来实现不停服务的情况下进行数据的拷贝，它的大致流程有如下三步：<br>1.锁表，我们知道，如果想保证数据一致，那么在进行复制时，锁表就是必须的一个步骤。<br>2.创建dump线程，执行数据同步操作。<br>3.释放表。</li></ul><h3 id="5-7新增的并行复制"><a href="#5-7新增的并行复制" class="headerlink" title="5.7新增的并行复制"></a>5.7新增的并行复制</h3><p>从前面的步骤我们可以分析出一个结论，就是复制的过程必然会导致大量延迟（这也是确实存在的），所以mysql从5.6开始，就在全力解决这个棘手的问题，5.6之后，mysql提出了一个并行复制的概念，即可以同时进行数据的备份，用于减少延迟，大致上来说，5.6的mysql是基于schema的并行复制策略，所以这种场景下其实是有一个弊端的，我们知道，mysql中，每一个schema可以理解为一个库，所以基于schema就意味着可以实现多个库的并行复制，但是我们平常大多数时候，一个项目通常只会有一个库，所以单库下，我们并不能使用mysql的并行复制功能。</p><p>而mysql 5.7开始，从新引入一个叫gtids的概念，即全局事务id，所以说这一个版本开始，就是基于事务的复制了，这样就解决了单库的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql的主从同步给构建大型系统带来了无限的可能性，接下来我们就简单介绍一下mysql的主动同步的基本原理以及实现方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是主从同步&quot;&gt;&lt;a href=&quot;#什么是主从同步&quot; class=&quot;headerlink&quot; title=&quot;什么是主
      
    
    </summary>
    
      <category term="Mysql" scheme="http://zhouyuhong.top/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="http://zhouyuhong.top/tags/mysql/"/>
    
      <category term="主从同步" scheme="http://zhouyuhong.top/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
