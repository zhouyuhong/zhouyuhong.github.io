<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>箫竹影</title>
  
  <subtitle>箫竹影的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhouyuhong.top/"/>
  <updated>2018-01-15T10:41:53.228Z</updated>
  <id>http://zhouyuhong.top/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper-Paxos算法理解</title>
    <link href="http://zhouyuhong.top/2018/01/14/Zookeeper-Paxos%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
    <id>http://zhouyuhong.top/2018/01/14/Zookeeper-Paxos算法理解/</id>
    <published>2018-01-14T11:40:23.000Z</published>
    <updated>2018-01-15T10:41:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。</p><hr><h3 id="分布式应用程序协调技术"><a href="#分布式应用程序协调技术" class="headerlink" title="分布式应用程序协调技术"></a>分布式应用程序协调技术</h3><p>要想了解zookeeper的工作机制，首先就要明白zookeeper是用来做什么的。我们前面提到过，zookeeper是一个分布式的应用程序协调服务，那么，什么又是分布式协调呢？其实可以简单的从字面上来理解，就是在多个应用程序（进程）之间来进行协调的，那么，这里的协调又是什么的？其实就是协调共享资源，我们知道，单机多线程应用环境下，对于共享资源，我们可以通过多线程安全技术来进行控制，其底层不外乎就是采用锁机制来保证同一时刻只能允许一个线程进行操作，那么分布式环境下就不那么容易了，相互隔离的各个应用之间，同样需要介入一项技术来保证顺序的访问某个临界资源，那么zookeeper就是这样一项技术。<br>而zookeeper就起到了前面介绍的单机多线程环境下的锁的作用，在分布式环境下，这种锁机制我们又称为分布式锁。</p><hr><h3 id="Paxos算法理论"><a href="#Paxos算法理论" class="headerlink" title="Paxos算法理论"></a>Paxos算法理论</h3><p>提到分布式锁，就不得不先来介绍一下paxos算法，这也是本篇博客的重点，简单的通过一句话来总结，paxos算法可以做到：</p><blockquote><p>所有节点都写入同一个值，并且之后不会再改变这个值</p></blockquote><p>而paxos算法又是基于2pc（2阶段提交协议）来做的，简单的说，其内部有一个提案机制，类似于议会制，通过两个阶段来完成一个提案：</p><ol><li>提案提交阶段</li><li>提案执行阶段</li></ol><p>其中，每一次提交阶段都会使用一个全局唯一的版本号，但是不代表整个提交阶段就一个版本，因为可能发生在第一个提案处于提交阶段的时候，又有第二个提案被发起了，那么这两个提案就会使用两个不同的版本号。同时需要注意的是，在一个流程中，当第二个阶段已经确认出了一个结果之后，即使此时还有处于第一个阶段的提案，也必须要同步成第二个阶段的提案。直到整个流程结束。</p><p>而整个全过程又需要多个角色来共同协作完成</p><ol><li><strong>proposer</strong>—提案发起者：proposer可以有多个，每一个proposer可以发起一个提案（该提案来自于客户端发起的某一个操作），提案可以是任何操作，比如修改某一个文件的值，删除某一个元素等等，多个proposer可以分别提出不同的提案，例如a发起修改某个元素x的值，b发起删除x这个元素，但是在一轮的流程中，最后只允许有一个提案被批准。</li><li><strong>acceptor</strong>—提案接受者：接受者有多个，proposer发起的提案必须有超过半数的acceptor批准，才能通过这个提案（假设此时有n个接受者，那么每一个提案必须至少有n / 2 + 1个acceptor的批准，才能通过，类似于我们常说的少数服从多数）；需要注意的是，各个acceptor是相互独立并且完全对等的。</li><li><strong>learner</strong>—提案学习者：这个角色就是用作最终学习决策使用的，主要用于当有不同的提案提交后，却发现acceptor已经同意了其他的提案，那么本次提议为了保证通过，就不得不将自己的提案修改为已经同意过的那个提案，而这个修改就是通过learner来进行同步的。</li><li><strong>client</strong>—客户端：即发起某个操作的角色。</li></ol><p>这几个角色的作用已经做了一个简单的介绍，并且为了保证少数服从多数，就要求我们的提案接受者数量至少是一个大于3的奇数个数量；介绍了这么多，相信看起来还是有点懵逼，接下来我们就用一个例子来补充讲解paxos算法的工作原理：<br>假设此时有两个部门，去争夺公司的某一个项目，每一个部门都派出了自己最得力的外交选手A和B，而公司的项目决定人有三个，张总，李总，王总<br>第一阶段：    </p><ul><li>此时A选手带上自己部门的贿赂奖金（类似于版本号）100元，去贿赂三个老总，显然，此时由于没有其他部门竞争，于是A选手顺利的与三个老总达成一致。</li><li>当A已经和张总以及李总签署完初步协议之后，此时不巧B选手也来了，B选手很聪明，他发现A还没有给王总签协议，于是他拿出了200元来贿赂王总，当A此时来找王总签字时，王总却说B已经给了我200元了，显然你的100元我是不会同意的。不过由于A已经和张总、李总初步达成了一致，产生了多数派，所以A也不必担心，于是A就跑回部门去说明本次交涉的结果，并且去取最终的合同，来找各位老总签字了。（这里注意一点，如果此时没有达成多数派，那么A肯定就会继续提高自己的价格，然后继续走一遍流程）</li><li>B显然最终肯定会另外的两个老总达成协议，因为他的钱比较多；当这轮结束之后，此时三个老总手里拿着的是B的协议（注意此时A并不知道这件事，他还以为自己的提案被接受了呢）。</li></ul><p>总而言之，第一阶段的最终目的就是要初步达成一个唯一的提案。</p><p>第二阶段：</p><ul><li>当A拿出了最终合同来找各位老总签字的时候，发现各位老总变卦了（因为第一个阶段最终达成的是B的初步协议），此时A便立刻进行下一步方案，提交自己的价格到300元，然后重新开始走第一个流程，但是当A与张总达成一致的时候，此时B发现情况不对，于是立刻找李总和王总达成了最终合同，同样此时已经达成了多数派，那么此时整个流程就会以B作为最终的结果了，显然，B所在的部门成功的中标，但是流程还没有结束，因为此时A还在重新走第一个流程。</li><li>此时A继续去找李总走第一个流程，虽然李总很眼馋这次的300元，但是由于已经和B达成了最终协议，所以他也不得不告诉A，他们已经决定让B所在的部门来做这个任务了。但是A心想：“吗的，老子刚在已经立下军令状了，总不可能就这样就回去了吧”，于是此时A灵机一动，把自己的提案内容擅自改成了B的，所以此时A手里也拿着B的提案内容。同时给李总签字，李总当然就同意了，此时又达成了多数派，并且此时再也没有B来搅局了。所以显然A的提案最终也会通过（当王总签字时，发现A的提案与B一样，所以他也就没有计较了）。</li></ul><p>这样做我们发现虽然最后A不得不违心的提交了B的提案，但是最终结果却是正确的。所以paxos就是通过这种方式来保证一致性的，即第二阶段优先进入的提案，会被执行，即使这个时候有更高的版本（例子中的贿赂金额），也会进行强制学习，让这些提案者同步自己的信息。这也是paxos解决一致性所采取的方式。</p><p>从上面介绍的机制可以看出，paxos算法真正耗时的就是在第二步了，这里需要超过半数的acceptor进行批准，中途必然会导致大量的io开销，同时在极限情况下，可能某个proposer发起的提案被一部分acceptor接受，而另一个proposer的提案被另一些acceptor接受，就会造成相互间的冲突，那么就会导致整个流程被大量的耗时在同步阶段。还是以上面例子，假设在第一个阶段，A通知了张总，B通知了王总和李总（此时已经满足多数派，B就回去拿合同），此时A去找李总或者王总时，就会发现自己的提案没有优势，那么他就必然会继续加钱，此时假设是300，通知了张总和王总（同样满足多数派，此时A就回去拿最终的合同了），此时B执行第二个阶段，发现自己的提案被A替代，那么此时B会继续加到400，然后通知王总和李总（然后又回去拿合同），此时A回来签署合同，发现又被B抬价了，那么A又继续加钱。。。所以我们不难发现，只要没有最终执行第二个阶段，就可能会导致多个提案被无限的更改，这就是所谓的活锁。由于paxos会导致活锁问题，所以市面上所有成熟的项目，都是基于paxos算法进行改进的，比如fast-paxos算法，zk的zab协议，都是用来解决这种现象的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;分布式应用程序协调技术&quot;&gt;&lt;a href=&quot;#分布式应用程序协调技术&quot; clas
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://zhouyuhong.top/categories/Zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://zhouyuhong.top/tags/zookeeper/"/>
    
      <category term="分布式" scheme="http://zhouyuhong.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从同步原理</title>
    <link href="http://zhouyuhong.top/2017/12/29/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://zhouyuhong.top/2017/12/29/MySQL主从同步实现原理/</id>
    <published>2017-12-29T08:02:58.000Z</published>
    <updated>2018-01-14T11:36:17.070Z</updated>
    
    <content type="html"><![CDATA[<p>mysql的主从同步给构建大型系统带来了无限的可能性，接下来我们就简单介绍一下mysql的主动同步的基本原理以及实现方式。</p><hr><h3 id="什么是主从同步"><a href="#什么是主从同步" class="headerlink" title="什么是主从同步"></a>什么是主从同步</h3><p>在mysql集群这个体系中，mysql会单独拿出一台机器作为主机器master，我们所有的insert，update，delete操作全部都在这台master服务器的库上，然后其他的机器全部作为这台机去的从节点slave，从节点的mysql会去master机器上获取最近一段时间的操作（通常很短暂），然后同步更新自己的数据，这样就达到了主从同步的操作。</p><p>这样的不同于传统的单机操作模式，带来的好处就是可以实现读写分离，集群扩展，数据的分区容错和高可用，数据备份等。</p><h3 id="主从同步实现方式"><a href="#主从同步实现方式" class="headerlink" title="主从同步实现方式"></a>主从同步实现方式</h3><p>那么，mysql是通过怎样的一种方式来实现主从同步的呢？其实很简单，在mysql内部，会有一个特殊的文件来记录着master上发生的一切，这个文件被叫做binary-log，俗称bin-log，这个文件所记录的操作被成为主从同步事件，每一个事件代表着一系列的intert，update，delete等操作，总体上，主从同步事件又大致分为三种：</p><ul><li>statement 即master上执行的所有sql语句会被完整的记录到bin-log中</li><li>row 即每一条记录的变化情况会被记录到bin-log中</li><li>mix 即同时混合前面的两种事件，结合使用</li></ul><p>当slave机器连接到master机器上时，master机器会开启一个叫做bin-dump的线程来管理这一个连接，当master的bin-log有改变的时候，dump线程会通知slave机器，同时将自己的更新内容同步给slave机器节点中。所以，一主多从下，master会有多个dump线程来维护多个slave服务器</p><p>同时，slave机器自身也会开启两个线程，一个叫做io线程，一个叫做sql线程，具体操作过程如下：</p><ul><li>io线程：接受master返回的bin-log中的更新内容，记录到本地的一个叫做中继日志中(relay.log)，当同步完成后，它会休眠，直到下一次master有更新时，通知它。</li><li>sql线程：从中继日志中获取最新的改变内容，然后在本地同步执行这些操作。这里有一个限制：master上可能有许多不影响的操作，它会并行执行，但是slave在同步这些操作时，只会串行化的执行这些操作。</li></ul><p>通过在master上执行命令可以查看当前master的dump线程：<br><img src="http://images-enjoylife.bj.bcebos.com/articles%2FMysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%2Fmysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A51.png" alt="Alt mysql master dump线程"></p><p>当然，在slave上执行命令也可以查看自己的io线程和sql线程：<br><img src="http://images-enjoylife.bj.bcebos.com/articles%2FMysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%2Fmysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A52.png" alt="Alt mysql slave io与sql线程"><br>从sql线程中我们可以看到确实是从一个叫relay.log中获取同步操作的。</p><h3 id="扩展slave节点"><a href="#扩展slave节点" class="headerlink" title="扩展slave节点"></a>扩展slave节点</h3><p>通常一个业务最开始都是从单机逐渐到集群的，所以mysql也是一样，我们很少有一开始就设置主从架构的应用，那么，如何在一个已有的服务器中添加从机器，或者从某一个已经有主从架构的服务商扩展一个新的slave呢？其实大致会有如下的几种方式：</p><ul><li>冷拷贝方式：即停止掉master节点，先进行数据复制，然后再启动，显然，这不是一个好的方案。</li><li>热拷贝方式：如果你是使用的myisam的存储引擎，那么你可以使用mysqlhotcopy程序来实现拷贝操作。</li><li>使用mysqldump方式：此时如果我们没有用myisam引擎，那么我们就可以通过dump来实现不停服务的情况下进行数据的拷贝，它的大致流程有如下三步：<br>1.锁表，我们知道，如果想保证数据一致，那么在进行复制时，锁表就是必须的一个步骤。<br>2.创建dump线程，执行数据同步操作。<br>3.释放表。</li></ul><h3 id="5-7新增的并行复制"><a href="#5-7新增的并行复制" class="headerlink" title="5.7新增的并行复制"></a>5.7新增的并行复制</h3><p>从前面的步骤我们可以分析出一个结论，就是复制的过程必然会导致大量延迟（这也是确实存在的），所以mysql从5.6开始，就在全力解决这个棘手的问题，5.6之后，mysql提出了一个并行复制的概念，即可以同时进行数据的备份，用于减少延迟，大致上来说，5.6的mysql是基于schema的并行复制策略，所以这种场景下其实是有一个弊端的，我们知道，mysql中，每一个schema可以理解为一个库，所以基于schema就意味着可以实现多个库的并行复制，但是我们平常大多数时候，一个项目通常只会有一个库，所以单库下，我们并不能使用mysql的并行复制功能。</p><p>而mysql 5.7开始，从新引入一个叫gtids的概念，即全局事务id，所以说这一个版本开始，就是基于事务的复制了，这样就解决了单库的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql的主从同步给构建大型系统带来了无限的可能性，接下来我们就简单介绍一下mysql的主动同步的基本原理以及实现方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是主从同步&quot;&gt;&lt;a href=&quot;#什么是主从同步&quot; class=&quot;headerlink&quot; title=&quot;什么是主
      
    
    </summary>
    
      <category term="Mysql" scheme="http://zhouyuhong.top/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="http://zhouyuhong.top/tags/mysql/"/>
    
      <category term="主从同步" scheme="http://zhouyuhong.top/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
