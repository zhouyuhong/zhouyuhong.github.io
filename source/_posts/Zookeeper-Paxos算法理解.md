---
title: Zookeeper-Paxos算法理解
date: 2018-01-14 19:40:23
categories: "Zookeeper"
tags:
	- zookeeper
	- 分布式
cover: https://ws4.sinaimg.cn/large/006tKfTcgy1fngfeqp8ilj31hs0iqgxy.jpg
subtitle: Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。
author: 
  nick: 箫竹影
  link: https://github.com/zhouyuhong
---
Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。
***
### 分布式应用程序协调技术
要想了解zookeeper的工作机制，首先就要明白zookeeper是用来做什么的。我们前面提到过，zookeeper是一个分布式的应用程序协调服务，那么，什么又是分布式协调呢？其实可以简单的从字面上来理解，就是在多个应用程序（进程）之间来进行协调的，那么，这里的协调又是什么的？其实就是协调共享资源，我们知道，单机多线程应用环境下，对于共享资源，我们可以通过多线程安全技术来进行控制，其底层不外乎就是采用锁机制来保证同一时刻只能允许一个线程进行操作，那么分布式环境下就不那么容易了，相互隔离的各个应用之间，同样需要介入一项技术来保证顺序的访问某个临界资源，那么zookeeper就是这样一项技术。
而zookeeper就起到了前面介绍的单机多线程环境下的锁的作用，在分布式环境下，这种锁机制我们又称为分布式锁。

### Paxos算法理论
提到分布式锁，就不得不先来介绍一下paxos算法，这也是本篇博客的重点，简单的通过一句话来总结，paxos算法可以做到：
> 所有节点都写入同一个值，并且之后不会再改变这个值

而paxos算法又是基于2pc（2阶段提交协议）来做的，简单的说，其内部有一个提案机制，类似于议会制，通过两个阶段来完成一个提案：
1. 提案提交阶段
2. 提案执行阶段

而整个全过程又需要三个角色来共同协作完成
1. proposer 提案发起者：proposer可以有多个，每一个proposer可以发起一个提案，提案可以是任何操作，比如修改某一个文件的值，删除某一个元素等等，多个proposer可以分别提出不同的提案，例如a发起修改某个元素x的值，b发起删除x这个元素，但是在一轮的流程中，最后只允许有一个提案被批准。
2. acceptor 提案接受者：接受者有多个，proposer发起的提案必须有超过半数的acceptor批准，才能通过这个提案（假设此时有n个接受者，那么每一个提案必须至少有n / 2 + 1个acceptor的批准，才能通过，类似于我们常说的少数服从多数）；需要注意的是，各个acceptor是相互独立并且完全对等的。
3. learner 提案学习者：这个角色的目的是基于第二点所提出的超过半数的接受者批准这一个前提条件而来的，超过半数以上的acceptor接受，就意味着可能会有某些acceptor没有批准，这个因素有很多，可能是网络，可能是它们批准了其他提案，那么，此时为了保证同步，这些acceptor就必须要将这个提案的结果同步过来，learner就是用来同步这些没有批准的acceptor的数据的。

从上面介绍的机制可以看出，paxos算法真正耗时的就是在第二步了，这里需要超过半数的acceptor进行批准，中途必然会导致大量的io开销，同时在极限情况下，可能某个proposer发起的提案被一部分acceptor接受，而另一个proposer的提案被另一些acceptor接受，就会造成相互间的冲突，那么就会导致整个流程被大量的耗时在同步阶段。所以，基于paxos算法，人们又提出了fast-paxos算法来解决这种现象。

