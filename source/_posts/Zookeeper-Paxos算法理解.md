---
title: Zookeeper-Paxos算法理解
date: 2018-01-14 19:40:23
categories: "Zookeeper"
tags:
	- zookeeper
	- 分布式
cover: https://ws2.sinaimg.cn/large/006tKfTcgy1fngfi15et6j31ks0wedyo.jpg
subtitle: Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。
author: 
  nick: 箫竹影
  link: https://github.com/zhouyuhong
---
Zookeeper，是一个分布式应用程序协调服务，是google的chubby的开源版实现，这篇博客就来简单介绍一下Zookeeper的基石-Paxos算法。
***
### 分布式应用程序协调技术
要想了解zookeeper的工作机制，首先就要明白zookeeper是用来做什么的。我们前面提到过，zookeeper是一个分布式的应用程序协调服务，那么，什么又是分布式协调呢？其实可以简单的从字面上来理解，就是在多个应用程序（进程）之间来进行协调的，那么，这里的协调又是什么的？其实就是协调共享资源，我们知道，单机多线程应用环境下，对于共享资源，我们可以通过多线程安全技术来进行控制，其底层不外乎就是采用锁机制来保证同一时刻只能允许一个线程进行操作，那么分布式环境下就不那么容易了，相互隔离的各个应用之间，同样需要介入一项技术来保证顺序的访问某个临界资源，那么zookeeper就是这样一项技术。
而zookeeper就起到了前面介绍的单机多线程环境下的锁的作用，在分布式环境下，这种锁机制我们又称为分布式锁。

***

### Paxos算法理论
提到分布式锁，就不得不先来介绍一下paxos算法，这也是本篇博客的重点，简单的通过一句话来总结，paxos算法可以做到：
> 所有节点都写入同一个值，并且之后不会再改变这个值

而paxos算法又是基于2pc（2阶段提交协议）来做的，简单的说，其内部有一个提案机制，类似于议会制，通过两个阶段来完成一个提案：
1. 提案提交阶段
2. 提案执行阶段

其中，每一次提交阶段都会使用一个全局唯一的版本号，但是不代表整个提交阶段就一个版本，因为可能发生在第一个提案处于提交阶段的时候，又有第二个提案被发起了，那么这两个提案就会使用两个不同的版本号。同时需要注意的是，在一个流程中，当第二个阶段已经确认出了一个结果之后，即使此时还有处于第一个阶段的提案，也必须要同步成第二个阶段的提案。直到整个流程结束。

而整个全过程又需要多个角色来共同协作完成
1. **proposer**—提案发起者：proposer可以有多个，每一个proposer可以发起一个提案（该提案来自于客户端发起的某一个操作），提案可以是任何操作，比如修改某一个文件的值，删除某一个元素等等，多个proposer可以分别提出不同的提案，例如a发起修改某个元素x的值，b发起删除x这个元素，但是在一轮的流程中，最后只允许有一个提案被批准。
2. **acceptor**—提案接受者：接受者有多个，proposer发起的提案必须有超过半数的acceptor批准，才能通过这个提案（假设此时有n个接受者，那么每一个提案必须至少有n / 2 + 1个acceptor的批准，才能通过，类似于我们常说的少数服从多数）；需要注意的是，各个acceptor是相互独立并且完全对等的。
3. **learner**—提案学习者：这个角色就是用作最终学习决策使用的，主要用于当有不同的提案提交后，却发现acceptor已经同意了其他的提案，那么本次提议为了保证通过，就不得不将自己的提案修改为已经同意过的那个提案，而这个修改就是通过learner来进行同步的。
4. **client**—客户端：即发起某个操作的角色。

这几个角色的作用已经做了一个简单的介绍，并且为了保证少数服从多数，就要求我们的提案接受者数量至少是一个大于3的奇数个数量；介绍了这么多，相信看起来还是有点懵逼，接下来我们就用一个例子来补充讲解paxos算法的工作原理：
假设此时有两个部门，去争夺公司的某一个项目，每一个部门都派出了自己最得力的外交选手A和B，而公司的项目决定人有三个，张总，李总，王总
第一阶段：	
* 此时A选手带上自己部门的贿赂奖金（类似于版本号）100元，去贿赂三个老总，显然，此时由于没有其他部门竞争，于是A选手顺利的与三个老总达成一致。
* 当A已经和张总以及李总签署完初步协议之后，此时不巧B选手也来了，B选手很聪明，他发现A还没有给王总签协议，于是他拿出了200元来贿赂王总，当A此时来找王总签字时，王总却说B已经给了我200元了，显然你的100元我是不会同意的。不过由于A已经和张总、李总初步达成了一致，产生了多数派，所以A也不必担心，于是A就跑回部门去说明本次交涉的结果，并且去取最终的合同，来找各位老总签字了。（这里注意一点，如果此时没有达成多数派，那么A肯定就会继续提高自己的价格，然后继续走一遍流程）
* B显然最终肯定会另外的两个老总达成协议，因为他的钱比较多；当这轮结束之后，此时三个老总手里拿着的是B的协议（注意此时A并不知道这件事，他还以为自己的提案被接受了呢）。

总而言之，第一阶段的最终目的就是要初步达成一个唯一的提案。

第二阶段：
* 当A拿出了最终合同来找各位老总签字的时候，发现各位老总变卦了（因为第一个阶段最终达成的是B的初步协议），此时A便立刻进行下一步方案，提交自己的价格到300元，然后重新开始走第一个流程，但是当A与张总达成一致的时候，此时B发现情况不对，于是立刻找李总和王总达成了最终合同，同样此时已经达成了多数派，那么此时整个流程就会以B作为最终的结果了，显然，B所在的部门成功的中标，但是流程还没有结束，因为此时A还在重新走第一个流程。
* 此时A继续去找李总走第一个流程，虽然李总很眼馋这次的300元，但是由于已经和B达成了最终协议，所以他也不得不告诉A，他们已经决定让B所在的部门来做这个任务了。但是A心想：“吗的，老子刚在已经立下军令状了，总不可能就这样就回去了吧”，于是此时A灵机一动，把自己的提案内容擅自改成了B的，所以此时A手里也拿着B的提案内容。同时给李总签字，李总当然就同意了，此时又达成了多数派，并且此时再也没有B来搅局了。所以显然A的提案最终也会通过（当王总签字时，发现A的提案与B一样，所以他也就没有计较了）。

这样做我们发现虽然最后A不得不违心的提交了B的提案，但是最终结果却是正确的。所以paxos就是通过这种方式来保证一致性的，即第二阶段优先进入的提案，会被执行，即使这个时候有更高的版本（例子中的贿赂金额），也会进行强制学习，让这些提案者同步自己的信息。这也是paxos解决一致性所采取的方式。

从上面介绍的机制可以看出，paxos算法真正耗时的就是在第二步了，这里需要超过半数的acceptor进行批准，中途必然会导致大量的io开销，同时在极限情况下，可能某个proposer发起的提案被一部分acceptor接受，而另一个proposer的提案被另一些acceptor接受，就会造成相互间的冲突，那么就会导致整个流程被大量的耗时在同步阶段。还是以上面例子，假设在第一个阶段，A通知了张总，B通知了王总和李总（此时已经满足多数派，B就回去拿合同），此时A去找李总或者王总时，就会发现自己的提案没有优势，那么他就必然会继续加钱，此时假设是300，通知了张总和王总（同样满足多数派，此时A就回去拿最终的合同了），此时B执行第二个阶段，发现自己的提案被A替代，那么此时B会继续加到400，然后通知王总和李总（然后又回去拿合同），此时A回来签署合同，发现又被B抬价了，那么A又继续加钱。。。所以我们不难发现，只要没有最终执行第二个阶段，就可能会导致多个提案被无限的更改，这就是所谓的活锁。由于paxos会导致活锁问题，所以市面上所有成熟的项目，都是基于paxos算法进行改进的，比如fast-paxos算法，zk的zab协议，都是用来解决这种现象的。
